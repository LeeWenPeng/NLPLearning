# 事件抽取

## 0 事件抽取概念

### 1 事件类型

+ 平坦事件：正常事件类型
+ 重叠事件：多个事件共享一个触发词
+ 嵌套事件：多个事件共享一个论元

## 1 事件抽取范式

### 1 基于管道

#### 1 概念

将事件抽取分解为多个独立子任务，并且每个任务看做分类问题，也就是将事件抽取认为看作为分阶段的多分类问题

#### 2 过程：

1. 对句子进行编码
2. 触发器识别并分类：检测识别触发词trigger，并基于trigger进行事件类别分类；
3. 论元识别：基于trigger和事件类型判断句中的词是否属于事件的论元，识别事件论元
4. 论元分类：对识别的论元进行角色分类，确定论元在事件中的角色类别

#### 3 缺点：

+ 误差传递：Pipeline的本质的问题，级联模型trigger分类阶段的错误、遗漏等误差会传递至argument分类阶段，无法被弥补召回，影响整体的性能
+ 缺乏交互：各个子任务之间相互独立，忽视子任务之间的关联性和影响

### 2 联合抽取

#### 1 概念

为了缓解 Pipeline 模式的误差累计问题，Joint 模型被提出和广泛的研究。同时抽取事件的触发词和论元。

#### 2 过程

1. 首先根据候选的 trigger 和实体识别句中的 trigger 和 argument
2. 同时进行 trigger 分类和 argument role 分类，两个分类子任务联合优化学习

#### 3 优点

+ 减少了子任务模型的数量
+ 增强了不同子任务模块之间的关联和交互，缓解了误差累计问题

#### 4 缺点

+ 误差传递仍然存在
+ 不能在不同事件类型之间共享信息并独立学习每种类型
+ 不利于仅使用少量标记数据进行事件提取

## 2 事件抽取方法

### 1 基于分类

#### 1 过程

1. 利用命名实体识别预先从文本中抽取出时间、地点、命名实体、以及非实体事件元素等构成候选事件论元集合$m$
2. 事件类别分类：从句子中识别触发词trigger，并基于触发词进行事件分类，预测事件类型 $e_i$ 
3. 论元角色分类：判断候选论元$m$中属于事件$e_i$的论元，对论元进行角色分类，预测论元角色$r_{i,j}$

#### 2 缺点

+ **不能解决overlapped事件和[nested事件](https://www.zhihu.com/search?q=nested事件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2789717634})的抽取**
+ **存在明显的误差累计问题：**事件论元识别和角色分类依赖于额外的命名实体识别模型的提取结果，即事件论元识别与论元分类是严重分离的，导致误差累计严重，性能较差；
+ **分类方法泛化能力较差**：基于分类的方法在遇到新的事件类型或论元类型时只能重新训练，泛化能力差。

### 2 基于序列标注

级别的多分类问题

#### 1 过程

1. 首先模型仍然是识别句子中的触发词并进行事件分类
2. 确定事件类型后，对句子进行词级别的序列标注，这一过程和命名实体识别是一样的，将论元角色类别和BIO标签组合分配给每一个词，从而获得事件的论元及其角色类别。

#### 2 优点

+ 不再依赖于额外的实体识别模型提取候选论元，而是将论元识别和角色分类统一至序列标注这一过程

#### 3 缺点

- **不能解决[overlapped事件](https://www.zhihu.com/search?q=overlapped事件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2789717634})和nested事件的抽取**
- **仍然存在误差累计：**实体类型到论元抽取过程存在事件类型的误差传递
- **泛化性差：**序列标注本质还是分类模型，训练好的模型无法处理新的事件类别和论元角色

### 3 基于阅读理解

事件抽取的四个子任务：

1. trigger识别 
2. trigger分类 
3. 论元识别
4. 论元角色分类

将每个子任务转化为阅读理解问题，整个事件抽取过程就可以看做多轮问答任务的执行

#### 1 过程

每个子任务抽取阶段都有对应的文本模板，通过在问题模型中嵌入识别的trigger、不同的事件类别、论元角色类别等信息构造问句与输入句子拼接进行答案生成或者答案片段的抽取，最终迭代的完成事件抽取。

#### 2 优点

+ **可以解决[falt事件](https://www.zhihu.com/search?q=falt事件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2789717634})、overlapped事件和nested事件的抽取**

+ **可以学习事件类别和论元类别标签的关联关系**：事件类别会出现在论元角色分类的问句中，已抽取的论元也可出现在后续论元抽取的问句中，直接建模了事件类别与论元角色，以及事件论元之间的依赖关系。

+ **泛化性强，模型可直接应用于新的事件类型和论元角色**：问句中可以为新的类别融入外部知识和信息

#### 3 缺点

+ **推断计算效率低：**在进行事件分类和论元角色分类时，需要将每个事件类别和论元角色类别进行问题构造，并与句子拼接进行单独判断，计算复杂度增加。

### 4 基于生成

#### 1 过程

在sequence-to-structure架构中对整个事件提取过程统一建模，并且所有触发词、论元及其角色类别标签都作为自然语言词统一的生成，以端到端的方式从文本中提取事件

通常采用BART、T5等encoder-decoder模型，这是一种将文本转换为结构化形式的简单方法

#### 2 优点

- **理想情况下可以解决falt事件、overlapped事件和nested事件的抽取**
- **端到端的统一建模：**不需要将事件抽取分解为多个子任务，避免了不同任务间的误差传播，也不需要人工设定不同任务组件间的信息共享和决策依赖关系，避免次优和不灵活的模型结构。
- 将文本转换为结构化形式

#### 3 缺点

**生成规范事件结构较困难：**[生成模型](https://www.zhihu.com/search?q=生成模型&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2789717634})生成的事件往往存在不准确、事件格式不规范、生成内容混乱不可控的问题，模型训练难度高，当前生成式抽取方法还未能完全超越抽取式抽取方法。

## 3 常用算法模型

![img](https://picx.zhimg.com/v2-1e21b3743e916dd73c8cb3217e0b28f1_r.jpg?source=2c26e567)